package com.seniorlibs.thread.basic;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.BlockingQueue;import static java.lang.Thread.interrupted;/** * Author: chen * Version: 1.0.0 * Date: 2020/11/28. * Mender: * Modify: * Description: 如何停止线程，interrupt 和 boolean标志位 */public class InterruptTest {    private static final String TAG = "InterruptTest";    /**     * interrupt的原生支持 -> Sleep()     */    public static void rawInterrupt() throws InterruptedException {        // 创建目标线程        Thread interruptRawThread = new Thread(() -> {            System.out.println(Thread.currentThread().getName() + " 线程正在执行...");            try {                Thread.sleep(5000);            } catch (InterruptedException e) {                e.printStackTrace();                System.out.println(Thread.currentThread().getName() + " 线程接收到中断信息，中断线程...");            }        }, "rawInterrupt");        // 启动目标线程        interruptRawThread.start();        // 中断通知        try {            Thread.sleep(2000);        } catch (InterruptedException e) {            e.printStackTrace();        }        System.out.println("rawInterrupt 设置线程中断....");        interruptRawThread.interrupt();//        rawInterrupt 线程正在执行...//        rawInterrupt 设置线程中断....//        rawInterrupt 线程接收到中断信息，中断线程...    }    /**     * 不支持 interrupt()     */    public static void unInterrupt() {        // 创建目标线程        Thread unInterruptThread = new Thread(() -> {            for (int i = 0; i < 100000; i++) {                if (i % 10000 == 0) {                    System.out.println(Thread.currentThread().getName() + " 线程正在执行... " + i);                }            }        }, "unInterrupt");        // 启动目标线程        unInterruptThread.start();        // 中断通知        System.out.println("unInterrupt 设置线程中断....");        unInterruptThread.interrupt();//        unInterrupt 设置线程中断....//        unInterrupt 线程正在执行... 0//        unInterrupt 线程正在执行... 10000//        unInterrupt 线程正在执行... 20000//        unInterrupt 线程正在执行... 30000//        unInterrupt 线程正在执行... 40000//        unInterrupt 线程正在执行... 50000//        unInterrupt 线程正在执行... 60000//        unInterrupt 线程正在执行... 70000//        unInterrupt 线程正在执行... 80000//        unInterrupt 线程正在执行... 90000    }    /**     * 支持 interrupted()     */    public static void supportInterrupted() {        // 创建目标线程        Thread supInterruptThread = new Thread(() -> {            for (int i = 0; i < 100000; i++) {                System.out.println(Thread.currentThread().getName() + " 线程正在执行... " + i);                // 判断当前线程是否中断，                if (interrupted()) {                    System.out.println(Thread.currentThread().getName() + " 线程接收到中断信息，中断线程...");                    break;                }            }        }, "supportInterrupted");        // 启动目标线程        supInterruptThread.start();        // 中断通知        try {            Thread.sleep(1);        } catch (InterruptedException e) {            e.printStackTrace();        }        System.out.println("supportInterrupted 设置线程中断....");        supInterruptThread.interrupt();//        supportInterrupted 设置线程中断....//        supportInterrupted 线程正在执行... 0//        supportInterrupted 线程接收到中断信息，中断线程...    }    /**     * 支持 IsInterrupted()     */    public static void supportIsInterrupted() {        // 创建目标线程        Thread supInterruptThread = new Thread(() -> {            for (int i = 0; i < 100000; i++) {                System.out.println(Thread.currentThread().getName() + " 线程正在执行... " + i + " isInterrupted()：" + Thread.currentThread().isInterrupted());                // 判断该线程是否中断，                if (Thread.currentThread().isInterrupted()) {                    System.out.println(Thread.currentThread().getName() + " 线程接收到中断信息，中断线程...");                    break;                }            }        }, "supportIsInterrupted");        // 启动目标线程        supInterruptThread.start();        // 中断通知        try {            Thread.sleep(1);        } catch (InterruptedException e) {            e.printStackTrace();        }        System.out.println("supportIsInterrupted 设置线程中断....");        supInterruptThread.interrupt();//        supportIsInterrupted 线程正在执行... 0 isInterrupted()：false//        supportIsInterrupted 线程正在执行... 1 isInterrupted()：false//        supportIsInterrupted 线程正在执行... 2 isInterrupted()：false//        supportIsInterrupted 设置线程中断....//        supportIsInterrupted 线程正在执行... 3 isInterrupted()：true//        supportIsInterrupted 线程接收到中断信息，中断线程...    }    /**     * 创建目标线程     */    static class BooleanThread extends Thread {        volatile boolean isStopped = false;        @Override        public void run() {            for (int i = 0; i < 100000; i++) {                System.out.println("volatileBoolean 线程正在执行... " + i);                // 判断该线程boolean标志位是否有效                if (isStopped) {                    System.out.println("volatileBoolean 线程接收到中断信息，中断线程...");                    break;                }            }        }    }    /**     * volatile boolean标志位     */    public static void volatileBoolean() {        BooleanThread booleanThread = new BooleanThread();        // 启动目标线程        booleanThread.start();        // 中断通知        try {            Thread.sleep(1);        } catch (InterruptedException e) {            e.printStackTrace();        }        System.out.println("volatileBoolean 设置线程中断....");        booleanThread.isStopped = true;//        volatileBoolean 设置线程中断....//        volatileBoolean 线程正在执行... 0//        volatileBoolean 线程接收到中断信息，中断线程...    }    /**     * volatile boolean标志位 不适用的例子     */    public static void volatileBooleanNot() {        try {            ArrayBlockingQueue storage = new ArrayBlockingQueue(8);            Producer producer = new Producer(storage);            Thread producerThread = new Thread(producer);            producerThread.start();            Thread.sleep(500);            Consumer consumer = new Consumer(storage);            while (consumer.needMoreNums()) {                System.out.println("volatileBooleanNot " + consumer.storage.take() + "被消费了");                Thread.sleep(100);            }            System.out.println("volatileBooleanNot 消费者不需要更多数据了。");            // 一旦消费不需要更多数据了，我们应该让生产者也停下来，但是实际情况却停不下来            producer.canceled = true;            System.out.println("volatileBooleanNot " + producer.canceled);        } catch (InterruptedException e) {            e.printStackTrace();        }        // 不能结束，不会打印：volatileBooleanNot 生产者结束运行//        volatileBooleanNot 0是50的倍数,被放到仓库中了。//        volatileBooleanNot 50是50的倍数,被放到仓库中了。//        volatileBooleanNot 100是50的倍数,被放到仓库中了。//        volatileBooleanNot 150是50的倍数,被放到仓库中了。//        volatileBooleanNot 0被消费了//        volatileBooleanNot 50被消费了//        volatileBooleanNot 消费者不需要更多数据了。//        volatileBooleanNot true    }    static class Producer implements Runnable {        public volatile boolean canceled = false;        public BlockingQueue storage;        public Producer(BlockingQueue storage) {            this.storage = storage;        }        @Override        public void run() {            int num = 0;            try {                while (num <= 100000 && !canceled) {                    // 生产者在执行storage.put(num)时发生阻塞，在它被叫醒之前是没有办法进入下一次循环判断canceled的值的，所以在这种情况下用volatile不能让生产者停下来。                    // 相反如果用interrupt语句来中断，即使生产者处于阻塞状态，仍然能够感受到中断信号，并做响应处理。                    if (num % 50 == 0) {                        storage.put(num);                        System.out.println("volatileBooleanNot " + num + "是50的倍数,被放到仓库中了。");                    }                    num++;                }            } catch (InterruptedException e) {                e.printStackTrace();            } finally {                System.out.println("volatileBooleanNot 生产者结束运行");            }        }    }    static class Consumer {        BlockingQueue storage;        public Consumer(BlockingQueue storage) {            this.storage = storage;        }        public boolean needMoreNums() {            if (Math.random() > 0.97) {                return false;            }            return true;        }    }}