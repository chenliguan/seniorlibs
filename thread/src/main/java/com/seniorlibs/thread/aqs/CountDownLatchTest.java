package com.seniorlibs.thread.aqs;import com.seniorlibs.baselib.threadpool.ThreadPoolManager;import java.util.concurrent.CountDownLatch;/** * Author: chen * Version: 1.0.0 * Date: 2019/9/1. * Mender: * Modify: * Description: 测试CountDownLatch * * CountDownLatch类位于java.util.concurrent包下，利用它可以实现类似计数器的功能。比如有一个任务A，它要等待其他4个任务执行完毕之后才能执行，此时就可以利用CountDownLatch来实现这种功能了。 * 调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行 * countDown():将count值减1 */public class CountDownLatchTest {    private static final String TAG = "CountDownLatchTest";    public static void main() {        normalTest();        // 一个线程等待其他多个线程都执行完毕，再继续自己的工作：裁判员等待 5 个运动员都跑到终点，宣布比赛结束        await();        // 多个线程等待某一个线程的信号，同时开始执行：发令枪响，比赛开始，于是 5 个子线程几乎同时开始跑步了        countDown();    }    /**     * 普通测试     */    public static void normalTest() {        final CountDownLatch latch = new CountDownLatch(2);        ThreadPoolManager.getInstance().executeIo(() -> {            try {                System.out.println(TAG + "1 子线程" + Thread.currentThread().getName() + "正在执行");                Thread.sleep(3000);                System.out.println(TAG + "1 子线程" + Thread.currentThread().getName() + "执行完毕");                latch.countDown();            } catch (InterruptedException e) {                e.printStackTrace();            }        });        ThreadPoolManager.getInstance().executeIo(() -> {            try {                System.out.println(TAG + "1 子线程" + Thread.currentThread().getName() + "正在执行");                Thread.sleep(3000);                System.out.println(TAG + "1 子线程" + Thread.currentThread().getName() + "执行完毕");                latch.countDown();            } catch (InterruptedException e) {                e.printStackTrace();            }        });        try {            System.out.println(TAG + "1 等待2个子线程执行完毕...");            latch.await();            System.out.println(TAG + "1 2个子线程已经执行完毕");            System.out.println(TAG + "1 继续执行主线程");        } catch (InterruptedException e) {            e.printStackTrace();        }//        CountDownLatchTest1 等待2个子线程执行完毕...//        CountDownLatchTest1 子线程ThreadPoolManager IO #1正在执行//        CountDownLatchTest1 子线程ThreadPoolManager IO #2正在执行//        CountDownLatchTest1 子线程ThreadPoolManager IO #1执行完毕//        CountDownLatchTest1 子线程ThreadPoolManager IO #2执行完毕//        CountDownLatchTest1 2个子线程已经执行完毕//        CountDownLatchTest1 继续执行主线程        // CountDownLatch 在倒数到 0  并且触发门闩打开后，就不能再次使用了，除非新建一个新的实例        // 重用后无效了，打印如下：//        CountDownLatchTest1 等待2个子线程执行完毕...//        CountDownLatchTest1 2个子线程已经执行完毕//        CountDownLatchTest1 继续执行主线程//        CountDownLatchTest1 子线程ThreadPoolManager IO #3正在执行//        CountDownLatchTest1 子线程ThreadPoolManager IO #4正在执行//        CountDownLatchTest1 子线程ThreadPoolManager IO #3执行完毕//        CountDownLatchTest1 子线程ThreadPoolManager IO #4执行完毕    }    /**     * 一个线程等待其他多个线程都执行完毕，再继续自己的工作：裁判员等待 5 个运动员都跑到终点，宣布比赛结束     */    public static void await() {        try {            // 该参数 count 是需要倒数的数值            CountDownLatch latch = new CountDownLatch(5);            for (int i = 0; i < 5; i++) {                final int no = i + 1;                ThreadPoolManager.getInstance().executeIo(new Runnable() {                    @Override                    public void run() {                        try {                            Thread.sleep((long) (Math.random() * 10000));                            System.out.println(TAG + " await() " + no + " 号运动员完成了比赛。");                        } catch (InterruptedException e) {                            e.printStackTrace();                        } finally {                            // 把数值倒数 1，也就是将 count 值减 1，直到减为 0 时，之前等待的线程会被唤起。                            // 每一个运动员跑到终点了，将 count 值减 1                            latch.countDown();                        }                    }                });            }            System.out.println(TAG + " await() " + "等待5个运动员都跑完.....");            // 调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行            // 裁判员等待 5 个运动员都跑到终点，宣布比赛结束            latch.await();        } catch (InterruptedException e) {            e.printStackTrace();        }        System.out.println(TAG + " await() " + "所有人都跑完了，比赛结束。");//        CountDownLatchTest await() 等待5个运动员都跑完.....//        CountDownLatchTest await() 1 号运动员完成了比赛。//        CountDownLatchTest await() 5 号运动员完成了比赛。//        CountDownLatchTest await() 4 号运动员完成了比赛。//        CountDownLatchTest await() 2 号运动员完成了比赛。//        CountDownLatchTest await() 3 号运动员完成了比赛。//        CountDownLatchTest await() 所有人都跑完了，比赛结束。    }    /**     * 多个线程等待某一个线程的信号，同时开始执行：发令枪响，比赛开始，于是 5 个子线程几乎同时开始跑步了     */    public static void countDown() {        System.out.println(TAG + " countDown() " + "运动员有5秒的准备时间");        CountDownLatch countDownLatch = new CountDownLatch(1);        for (int i = 0; i < 5; i++) {            final int no = i + 1;            ThreadPoolManager.getInstance().executeIo(new Runnable() {                @Override                public void run() {                    System.out.println(TAG + " countDown() " + no + "号运动员准备完毕，等待裁判员的发令枪");                    try {                        countDownLatch.await();                        System.out.println(TAG + " countDown() " + no + "号运动员开始跑步了");                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }            });        }        try {            Thread.sleep(5000);        } catch (InterruptedException e) {            e.printStackTrace();        }        System.out.println(TAG + " countDown() " + "5秒准备时间已过，发令枪响，比赛开始！");        // 把数值倒数 1，也就是将 count 值减 1，直到减为 0 时，之前等待的所有线程会被唤起。        countDownLatch.countDown();//        CountDownLatchTest countDown() 运动员有5秒的准备时间//        CountDownLatchTest countDown() 1号运动员准备完毕，等待裁判员的发令枪//        CountDownLatchTest countDown() 2号运动员准备完毕，等待裁判员的发令枪//        CountDownLatchTest countDown() 3号运动员准备完毕，等待裁判员的发令枪//        CountDownLatchTest countDown() 5号运动员准备完毕，等待裁判员的发令枪//        CountDownLatchTest countDown() 4号运动员准备完毕，等待裁判员的发令枪//        CountDownLatchTest countDown() 5秒准备时间已过，发令枪响，比赛开始！//        CountDownLatchTest countDown() 1号运动员开始跑步了//        CountDownLatchTest countDown() 3号运动员开始跑步了//        CountDownLatchTest countDown() 2号运动员开始跑步了//        CountDownLatchTest countDown() 5号运动员开始跑步了//        CountDownLatchTest countDown() 4号运动员开始跑步了    }}