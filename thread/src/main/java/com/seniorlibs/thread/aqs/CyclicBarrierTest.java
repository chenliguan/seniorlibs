package com.seniorlibs.thread.aqs;import com.seniorlibs.baselib.threadpool.ThreadPoolManager;import java.util.concurrent.BrokenBarrierException;import java.util.concurrent.CyclicBarrier;/** * Author: chen * Version: 1.0.0 * Date: 2020/12/29. * Mender: * Modify: * Description: 测试CyclicBarrier * <p> * CyclicBarrier 和 CountDownLatch 确实有一定的相似性，它们都能阻塞一个或者一组线程，直到某种预定的条件达到之后，这些之前在等待的线程才会统一出发，继续向下执行。 */public class CyclicBarrierTest {    private static final String TAG = "CyclicBarrierTest";    private static final int THREAD_COUNT = 6;    public static void main() {        // 首先建了一个参数为 3 的 CyclicBarrier，参数为 3 的意思是需要等待 3 个线程到达这个集结点才统一放行        CyclicBarrier cyclicBarrier = new CyclicBarrier(3, new Runnable() {            @Override            public void run() {                // 执行动作 barrierAction：每个周期只打印一次                System.out.println(TAG + " 凑齐3人了，出发！");            }        });        for (int i = 0; i < THREAD_COUNT; i++) {            ThreadPoolManager.getInstance().executeIo(new Task(i + 1, cyclicBarrier));        }//        CyclicBarrierTest 同学1现在从大门出发，前往自行车驿站//        CyclicBarrierTest 同学2现在从大门出发，前往自行车驿站//        CyclicBarrierTest 同学3现在从大门出发，前往自行车驿站//        CyclicBarrierTest 同学4现在从大门出发，前往自行车驿站//        CyclicBarrierTest 同学5现在从大门出发，前往自行车驿站//        CyclicBarrierTest 同学6现在从大门出发，前往自行车驿站//        CyclicBarrierTest 同学4到了自行车驿站，开始等待其他人到达//        CyclicBarrierTest 同学6到了自行车驿站，开始等待其他人到达//        CyclicBarrierTest 同学5到了自行车驿站，开始等待其他人到达//        CyclicBarrierTest 凑齐3人了，出发！//        CyclicBarrierTest 同学5开始骑车//        CyclicBarrierTest 同学4开始骑车//        CyclicBarrierTest 同学6开始骑车//        CyclicBarrierTest 同学3到了自行车驿站，开始等待其他人到达//        CyclicBarrierTest 同学2到了自行车驿站，开始等待其他人到达//        CyclicBarrierTest 同学1到了自行车驿站，开始等待其他人到达//        CyclicBarrierTest 凑齐3人了，出发！//        CyclicBarrierTest 同学1开始骑车//        CyclicBarrierTest 同学3开始骑车//        CyclicBarrierTest 同学2开始骑车    }    static class Task implements Runnable {        private int id;        private CyclicBarrier cyclicBarrier;        public Task(int id, CyclicBarrier cyclicBarrier) {            this.id = id;            this.cyclicBarrier = cyclicBarrier;        }        @Override        public void run() {            System.out.println(TAG + " 同学" + id + "现在从大门出发，前往自行车驿站");            try {                Thread.sleep((long) (Math.random() * 10000));                System.out.println(TAG + " 同学" + id + "到了自行车驿站，开始等待其他人到达");                // 一旦它调用了await() 方法，它就会陷入等待，直到三个人凑齐，才会继续往下执行，一旦开始继续往下执行，就意味着 3 个同学开始一起骑车了                cyclicBarrier.await();                System.out.println(TAG + " 同学" + id + "开始骑车");            } catch (InterruptedException e) {                e.printStackTrace();            } catch (BrokenBarrierException e) {                e.printStackTrace();            }        }    }}