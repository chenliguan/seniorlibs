package com.seniorlibs.thread.aqs;import com.seniorlibs.baselib.utils.LogUtils;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Semaphore;/** * Author: chen * Version: 1.0.0 * Date: 2019/9/1. * Mender: * Modify: * Description: 测试Semaphore */public class SemaphoreTest {    private static final String TAG = "SemaphoreTest";    private static final int THREAD_COUNT = 10;    /**     * 测试acquire()     */    public static void testAcquire() {        ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_COUNT);        Semaphore semaphore = new Semaphore(3);        for (int i = 0; i < THREAD_COUNT; i++) {            threadPool.execute(new Runnable() {                @Override                public void run() {                    try {                        semaphore.acquire();                        LogUtils.d(TAG, "testAcquire :");                        Thread.sleep(1000);                        semaphore.release();                    } catch (InterruptedException e) {                        LogUtils.d(TAG, "InterruptedException：" + e.toString());                    }                }            });        }        threadPool.shutdown();    }    /**     * 测试tryAcquire()     */    public static void testTryAcquire() {        ExecutorService threadPool = Executors.newFixedThreadPool(THREAD_COUNT);        Semaphore semaphore = new Semaphore(3);        for (int i = 0; i < THREAD_COUNT; i++) {            threadPool.execute(new Runnable() {                @Override                public void run() {                    if (!semaphore.tryAcquire()) {                        LogUtils.d(TAG, "permits.tryAcquire() semaphore.tryAcquire() ：true");                        return;                    }                    LogUtils.d(TAG, "permits.tryAcquire()：2");                }            });        }        threadPool.shutdown();    }}