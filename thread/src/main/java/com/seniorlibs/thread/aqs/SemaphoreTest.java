package com.seniorlibs.thread.aqs;import com.seniorlibs.baselib.threadpool.ThreadPoolManager;import com.seniorlibs.baselib.utils.LogUtils;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Semaphore;/** * Author: chen * Version: 1.0.0 * Date: 2019/9/1. * Mender: * Modify: * Description: 测试Semaphore * <p> * 信号量的一个最主要的作用就是，来控制那些需要限制并发访问量的资源。 */public class SemaphoreTest {    private static final String TAG = "SemaphoreTest";    private static final int THREAD_COUNT = 9;    /**     * 测试acquire()     */    public static void testAcquire() {        Semaphore semaphore = new Semaphore(3);        for (int i = 0; i < THREAD_COUNT; i++) {            ThreadPoolManager.getInstance().executeIo(() -> {                try {                    // 最多只有3个线程可以同时访问服务                    semaphore.acquire();                    LogUtils.d(TAG, Thread.currentThread().getName() + " semaphore.testAcquire 调用了服务 ");                    Thread.sleep(1000);                    semaphore.release();                } catch (InterruptedException e) {                    LogUtils.d(TAG, "InterruptedException：" + e.toString());                }            });        }        // 没一秒最多3个线程执行//        16:17:28.293 ThreadPoolManager IO #1 semaphore.testAcquire 调用了服务//        16:17:28.295 ThreadPoolManager IO #2 semaphore.testAcquire 调用了服务//        16:17:28.297 ThreadPoolManager IO #3 semaphore.testAcquire 调用了服务//        16:17:29.294 ThreadPoolManager IO #4 semaphore.testAcquire 调用了服务//        16:17:29.296 ThreadPoolManager IO #5 semaphore.testAcquire 调用了服务//        16:17:29.298 ThreadPoolManager IO #6 semaphore.testAcquire 调用了服务//        16:17:30.295 ThreadPoolManager IO #7 semaphore.testAcquire 调用了服务//        16:17:30.297 ThreadPoolManager IO #8 semaphore.testAcquire 调用了服务//        16:17:30.299 ThreadPoolManager IO #9 semaphore.testAcquire 调用了服务    }    /**     * 测试tryAcquire()     */    public static void testTryAcquire() {        Semaphore semaphore = new Semaphore(3);        for (int i = 0; i < THREAD_COUNT; i++) {            ThreadPoolManager.getInstance().executeIo(() -> {                if (semaphore.tryAcquire()) {                    // 耗时操作                    try {                        Thread.sleep(1000);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                    LogUtils.d(TAG, Thread.currentThread().getName() + " 得到了许可，进入执行逻辑");                    semaphore.release();                } else {                    LogUtils.e(TAG, Thread.currentThread().getName() + " 没有得到许可");                }            });        }//        ThreadPoolManager IO #4 没有得到许可//        ThreadPoolManager IO #5 没有得到许可//        ThreadPoolManager IO #6 没有得到许可//        ThreadPoolManager IO #7 没有得到许可//        ThreadPoolManager IO #8 没有得到许可//        ThreadPoolManager IO #9 没有得到许可//        ThreadPoolManager IO #1 得到了许可，进入执行逻辑//        ThreadPoolManager IO #2 得到了许可，进入执行逻辑//        ThreadPoolManager IO #3 得到了许可，进入执行逻辑    }}