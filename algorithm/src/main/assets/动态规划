
一、解决动态规划的思维框架  https://labuladong.gitee.io/algo/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AF%A6%E8%A7%A3%E8%BF%9B%E9%98%B6.html
1、动态规划的定性
（1）首先，动态规划问题的一般形式就是 求最值。例如：最长公共子序列，最小编辑距离

（2）既然是要求最值，核心问题是什么呢？
    求解动态规划的核心问题是 穷举，穷举所有可能性，然后在其中找最值。算法设计就是先思考 “如何穷举”，然后再追求 “如何聪明地穷举”：
    ①列出动态转移方程，就是在解决“如何穷举”的问题，而穷举需要递归实现。
    ②备忘录、DP table 就是在追求“如何聪明地穷举”。用空间换时间的思路，是降低时间复杂度的不二法门。

（3）(3.1)动态规划问题一定会具备「最优子结构」，才能通过子问题的最值得到原问题的最值；
     (3.2)动态规划的穷举有点特别，因为这类问题存在「重叠子问题」。如果暴力穷举效率极其低下，所以需要「备忘录」或者「DP table」来优化穷举过程；
     (3.3)问题可以千变万化，穷举所有解并不容易，只有列出正确的「状态转移方程」才能正确地穷举；
     (3.4)以上提到的「最优子结构」、「重叠子问题」、「状态转移方程」就是动态规划三要素。


2、一个动态规划的思维框架
（1）辅助你思考状态转移方程
    (1.1)明确 base case。
    (1.2)明确「状态」，也就是原问题和子问题中会变化的变量。
    (1.3)明确「选择」，也就是导致「状态」产生变化的行为。
    (1.4)定义 dp 数组/函数的含义。
    (1.5)写出状态转移方程（dp方程），dp[i] = ....。

（2）按上面的套路走，最后的结果就可以套这个框架：
    // 初始化 base case
    dp[0][0][...] = base
    // 进行状态转移
    for (状态1 in 状态1的所有取值)
        for (状态2 in 状态2的所有取值)
            for ...
                dp[状态1][状态2][...] = 求最值(选择1，选择2...)

（3）根据（1）和（2）以及 求最值的逻辑，输出代码

（4）状态压缩
    每次状态转移只需要DP table中的一部分，可以尝试用状态压缩来缩小DP table的大小，只记录必要的数据。
    看它的状态转移方程，如果计算状态 dp[i][j] 需要的都是 dp[i][j] 相邻的状态，那么就可以使用状态压缩技巧，将二维的 dp 数组转化成一维，将空间复杂度从 O(N^2) 降低到 O(N)。
    如果dp[i] 仅仅和 dp[i-1] 的状态有关，那么我们可以进行「状态压缩」，将空间复杂度降低：


3、「最优子结构」：要求子问题之间必须互相独立，然后可以从子问题的最优结果推出更大规模问题的最优结果。
    动态规划就是从最简单的 base case 往后推导，可以想象成一个链式反应，不断以小博大。但只有符合「最优子结构」的问题，才有发生这种链式反应的性质；
（1）特点
    (1.1)「最优子结构」并不是动态规划独有的一种性质，能求最值的问题大部分都具有这个性质；但反过来，最优子结构性质作为动态规划问题的必要条件，一定是让你求最值的；
    (1.2)找最优子结构的过程，其实就是证明「状态转移方程」正确性的过程，方程符合最优子结构就可以写暴力解了，写出暴力解就可以看出有没有「重叠子问题」了，有则优化，无则 OK。

（2）案例，学校有10个班
    符合：计算每个班的最优成绩就是子问题，知道所有子问题的答案后，就能推出全校学生的最优成绩这个更大的问题的答案。因为全校的最高分数只会出现在1个班，子问题之间互相独立。
    不符合：计算每个班的最大分数差就是子问题，知道所有子问题的答案后，不能推出全校学生的最大分数差。因为全校的最大分数差可能是3班的最高分和6班的最低分之差，子问题之间不互相独立。
    改造问题：把问题等价转化，最大分数差 等价于 最高分数和最低分数的差，只要求最高和最低分数即可。


二、通过 斐波那契数列 解释如何通过「备忘录」或者「dp table」的方法来优化递归树
1、暴力递归
（1）斐波那契数列的数学形式就是递归的，写成代码就是这样：
fun fib1(n: Int): Int {
    if (n <= 0) return 0
    if (n == 1 || n == 2) return 1

    return fib1(n - 1) + fib1(n - 2)
}

（2）递归算法的时间复杂度怎么计算？
    就是用 子问题个数 乘以 解决一个子问题需要的时间。
    首先计算子问题个数，即递归树中节点的总数。显然二叉树节点总数为指数级别，所以子问题个数为 O(2^n)。
    然后计算解决一个子问题的时间，在本算法中，没有循环，只有 f(n - 1) + f(n - 2) 一个加法操作，时间为 O(1)。所以，这个算法的时间复杂度为二者相乘，即 O(2^n)，指数级别，爆炸。

（3）观察递归树，很明显发现了算法低效的原因：存在大量重复计算，比如 f(18) 被计算了两次，而且以 f(18) 为根的这个递归树体量巨大，多算一遍会耗费巨大的时间。
    更何况，还不止 f(18) 这一个节点被重复计算，所以这个算法及其低效。这就是动态规划问题的第一个性质：「重叠子问题」。

 （4）PS：但凡遇到需要递归的问题，最好都画出递归树，这对你分析算法的复杂度，寻找算法低效的原因都有巨大帮助。

2、带备忘录的递归解法
（1）思路
    明确了问题，其实就已经把问题解决了一半。既然耗时的原因是重复计算，那可以在每次算出某个子问题的答案后别急着返回，先记到备忘录里再返回（一般使用数组充当备忘录）；
    每次遇到一个子问题先去「备忘录」里查，如果发现之前已经解决过这个问题了，直接把答案拿出来用，不要再耗时去计算了。

（2）
private var cache = IntArray(31)

fun fib2(n: Int): Int {
    if (n <= 0) return 0
    if (n == 1 || n == 2) return 1

    cache[0] = 0
    cache[1] = 1
    return fibs(n)
}

private fun fibs(n: Int): Int {
    // 如果 N 对应的斐波那契数存在，则返回
    if (cache[n] != 0) return cache[n]

    // 计算 N 对应的斐波那契数为 fb(N-1) + fb(N-2)
    cache[n] = fibs(n - 1) + fibs(n - 2)
    return cache[n]
}

（3）本质：带备忘录的递归算法，把一棵存在巨量冗余的递归树通过「剪枝」，改造成了一幅不存在冗余的递归图，极大减少了子问题（即递归图中节点）的个数

（4）时间复杂度：子问题个数，即图中节点的总数，由于本算法不存在冗余计算，子问题就是 f(1), f(2), f(3) ... f(20)，数量和输入规模 n = 20 成正比，所以子问题个数为 O(n)。
    解决一个子问题的时间，同上，没有什么循环，时间为 O(1)。所以，本算法的时间复杂度是 O(n)。比起暴力算法，是降维打击。

（5）备忘录和动态规划有什么区别？
    这种解法和迭代的动态规划已经差不多了，只不过这种方法叫做「自顶向下」，动态规划叫做「自底向上」。
    啥叫「自顶向下」？注意刚画的递归树是从上向下延伸，都是从一个规模较大的原问题比如说 f(20)，向下逐渐分解规模，直到 f(1) 和 f(2) 这两个 base case，然后逐层返回答案；
    啥叫「自底向上」？反过来，直接从最底下，问题规模最小的 f(1) 和 f(2) 开始往上推，直到推到想要的答案 f(20)，这就是动态规划的思路，这也是为什么动态规划都脱离了递归，而是由循环迭代完成计算。


3、dp 数组的迭代解法
（1）有了上一步「备忘录」的启发，我们可以把这个「备忘录」独立出来成为一张表叫做 DP table，特别像「备忘录」中剪枝后的结果，只是反过来算而已。
（2）
fun fib3(n: Int): Int {
    if (n <= 0) return 0
    if (n == 1 || n == 2) return 1

    val dp = IntArray(n + 1)
    // base case
    dp[0] = 0
    dp[1] = 1

    // dp
    for (i in 2 until n + 1) {
        dp[i] = dp[i - 1] + dp[i - 2]
    }

    return dp[n]
}

（3）这里，引出「状态转移方程」这个名词，实际上就是描述问题结构的数学形式：
    fib(n) = 1，n = 1,2
    fib(n) = fib(n - 1) + fib(n - 2)，n > 2
    为啥叫「状态转移方程」？把f(n)想做一个状态n，这个状态n是由状态n - 1和状态n - 2相加转移而来，这就叫状态转移。它是解决问题的核心，而且它直接代表着暴力解法。

4、状态压缩
（1）根据状态转移方程，当前状态只和之前的两个状态有关，不需要那么长的 DP table 来存储所有的状态，只要存储之前的两个状态即可。所以，经过优化后把空间复杂度降为 O(1)：
（2）
fun fib4(n: Int): Int {
    if (n <= 0) return 0
    if (n == 1 || n == 2) return 1

    var pre = 1   // fib(1)
    var cur = 1   // fib(2)

    for (i in 3 until n + 1) {
        val sum = pre + cur
        pre = cur
        cur = sum
    }

    return cur
}


三、通过 凑零钱问题 展示如何流程化确定「状态转移方程」
1、凑零钱 符合最优子结构：
    比如想求 amount = 11 时的最少硬币数（原问题），如果知道凑出 amount = 10 的最少硬币数量（子问题），只需要把子问题的结果加1（再选一枚面值为 1 的硬币）就是原问题的答案。
    因为硬币的数量是没有限制的，所以子问题之间没有相互制，是互相独立的。

2、如何流程化确定「状态转移方程」？
    (2.1)确定 base case，目标金额 amount 为 0 时算法返回 0，因为不需要任何硬币就已经凑出目标金额了。
    (2.2)确定「状态」，也就是原问题和子问题中会变化的变量。由于硬币数量无限，硬币的面值也是题目给定的，只有目标金额会不断地向 base case 靠近，所以唯一的「状态」就是目标金额amount -> i。
    (2.3)确定「选择」，也就是导致「状态」产生变化的行为。当你每选择一枚硬币，目标金额就会减少，所以每一枚硬币的面值coin，就是你的「选择」。
    (2.4)明确 dp 数组的定义。dp 数组把「状态」，也就是目标金额作为变量；dp 数组的定义：当目标金额为 i 时，至少需要 dp[i] 硬币数。
    (2.5)写出状态转移方程（dp方程），dp[i] = Math.min(dp[i], i + dp[i - coin])

3、按上面的套路走，最后的结果就可以套这个框架：
    // 初始化 base case
    dp[0][0][...] = base
    // 进行状态转移
    for (状态1 in 状态1的所有取值)
        for (状态2 in 状态2的所有取值)
            for ...
                dp[状态1][状态2][...] = 求最值(选择1，选择2...)

4、根据（1）和（2）以及 求最值的逻辑，输出代码
    // 外层 for 循环在遍历所有状态的所有取值
    for (i in 1..amount) {
        // 内层 for 循环在遍历硬币的面值，求所有选择的最小值
        for (coin in coins) {
            // dp：动态转移方程
            dp[i] = Math.min(dp[i], i + dp[i - coin])
        }
    }

5、状态压缩
    每次状态转移只需要DP table中的一部分，可以尝试用状态压缩来缩小DP table的大小，只记录必要的数据。一维的 DP table 可以压缩为常数。


四、最大子序和，也叫:最大子数组和（连续的序列）
1、最大子数组和 符合最优子结构：
    如果nums[0..i] 中的「最大的子数组和」为 dp[i]，dp[i] 不能推出 dp[i+1]。因为如果从[0-->i]的最大值是可以的，但是0位置会变[2-->4]!=[3-->5]
    而以 nums[i] 为结尾的「最大子数组和」为 dp[i]，符合最优子结构。这种定义之下，想得到整个 nums 数组的「最大子数组和」，不能直接返回 dp[n-1]，而需要遍历整个 dp 数组。

2、如何流程化确定「状态转移方程」？
    (2.1)确定 base case，第一个元素前面没有子数组，dp[0] = nums[0]。
    (2.2)确定「状态」，也就是原问题和子问题中会变化的变量。元素下标 --> i。
    (2.3)确定「选择」，也就是导致「状态」产生变化的行为。dp[i] 有两种「选择」，要么与前面的相邻子数组连接，形成一个和更大的子数组；要么不与前面的子数组连接，自己作为一个子数组。选择结果更大的
    (2.4)明确 dp 数组的定义。dp 数组的定义：当选中第 i 状态时，以 nums[i] 为结尾的「最大子数组和」为 dp[i]。
    (2.5)写出状态转移方程（dp方程），dp[i] = Math.max(nums[i], nums[i] + dp[i - 1]);

3、按上面的套路走，最后的结果就可以套这个框架：
    // 初始化 base case
    dp[0][0][...] = base
    // 进行状态转移
    for (状态1 in 状态1的所有取值)
        for (状态2 in 状态2的所有取值)
            for ...
                dp[状态1][状态2][...] = 求最值(选择1，选择2...)

4、根据（1）和（2）以及 求最值的逻辑，输出代码
    // 状态转移方程
    for (int i = 1; i < n; i++) {
        dp[i] = Math.max(nums[i], nums[i] + dp[i - 1]);
    }
    // 得到 nums 的最大子数组
    int res = Integer.MIN_VALUE;
    for (int i = 0; i < n; i++) {
        res = Math.max(res, dp[i]);
    }

5、状态压缩
    注意到 dp[i] 仅仅和 dp[i-1] 的状态有关，那么我们可以进行「状态压缩」，将空间复杂度降低：。

    int dp_0 = nums[0];
    int dp_1 = 0, res = dp_0;

    for (int i = 1; i < n; i++) {
        // dp[i] = max(nums[i], nums[i] + dp[i-1])
        dp_1 = Math.max(nums[i], nums[i] + dp_0);
        dp_0 = dp_1;
        // 顺便计算最大的结果
        res = Math.max(res, dp_1);
    }


五、动态规划
1、特点
动态规划和递归或者分治没有根本上的区别（关键看有无最优的子结构)
 1.共性:找到重复子问题
 2.差异性:最优子结构、中途可以淘太欠优解

递归问题：含有重疊的子问题，操作重复
 1.记忆化搜索(自顶而下)
 2.动态规划(自底而上)

常识：一般求解最值的问题都可以朝着动态规划的方向去想

2、关键点：
 1.根据最优子结构定义状态：dp[n] = bestOf(dp[n-1], dp[n-2], ...)
 2.递推状态转移方程（DP方程）
   一维：dp[i] = dp[n-1] + dp[n-2]
   二维: dp[i,j] = dp[i+1], i] + dp[i][j+1] (且判断dp[i, j]是否空地)
 3.考虑初始化（base case）
 4.考虑输出
 5.考虑优化空间

3、思考思路：想到动态规划，但又不知从何入手，可以试试这么思考：
 1.大问题是什么？
 2.规模小一点的子问题是什么？
 3.它们之间有什么联系？

4、大问题是一个字符串是否是回文串，那规模小一点的子问题呢？
 一个字符串是回文串，它的首尾字符相同，且剩余子串也是一个回文串。所以，剩余子串是否为回文串，就是规模小一点的子问题，它的结果影响大问题的结果。
 我们怎么去描述子问题呢？写出
 （1）base case：只有一个字母的时候肯定是回文子串，for (i in 0 until n) dp[i][i] = true
 （2）db方程：
    // 如果s[i]==s[j]，说明只要dp[i+1][j-1]是回文子串，那么dp[i][j]也是回文子串；如果s[i]!=s[j]，说明dp[i][j]必定不是回文子串。
    if(s.charAt(i) == s.charAt(j)){
        dp[i][j] = dp[i+1][j-1]
    } else {
        dp[i][j] = false;
    }

