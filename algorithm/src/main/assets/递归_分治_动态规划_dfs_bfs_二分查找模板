
一、递归思维要点
1、不要人肉进行递归（最大误区），初学者可以在纸上画出递归的状态树，慢慢熟练之后一定要抛弃这样的习惯。一定要记住：直接看函数本身开始写即可。否则，永远没办法掌握、熟练使用递归。
2、找到最近最简的方法，将其拆解成可重复解决的问题（找最近重复子问题）。原因是我们写的程序的指令，只包括 if else 、 for 和 while loop、递归调用。
3、数学归纳法的思维，最开始最简单的条件是成立的，比如n=1,n=2的时候是成立的，且第二点你能证明当n成立的时候，可以推导出n+1也成立的。

4、碰到一个题目，就会找到他的重复性：
  （1）最优重复性：动态规划；
  （2）最近重复性：根据重复性的构造和分解，便有分治和回溯。

5、递归算法的时间复杂度怎么计算？就是用：子问题个数（递归树中节点的总数） 乘以 解决一个子问题需要的时间。


二、递归模板
public void recur(int level, int param) {
  // 1.递归终结条件（最先写）
  if (level > MAX_LEVEL) {
    // process result
    return;
  }

  // 2.处理当前层逻辑
  process(level, param);

  // 3.下探到下一层，关键：level + 1
  recur(level: level + 1, newParam);

  // 4.清理恢复当前层
  revertStates();
}


三、分治模板
public void recur(int level, int param) {
  // 1.递归终结条件（最先写）
  if (level > MAX_LEVEL) {
    // process result
    return;
  }

  // 2.处理当前层逻辑
  process(level, param);

  // 3.调用函数下探到下一层，解决更细节的子问题
  int subresult1 = recur(level: level + 1, newParam);
  int subresult2 = recur(level: level + 1, newParam);
  int subresult3 = recur(level: level + 1, newParam);

  // 4.将子问题的解的合并，产生最终结果
  int result = processResult(subresult1, subresult2, subresult3, …);

  // 5.清理恢复当前层
  revertStates();
}


四、回溯
回溯算法是一种 有方向地 遍历搜索算法，以 深度优先遍历 的方式尝试所有的可能性。但不同的是在搜索过程中，达到结束条件后，恢复状态，回溯上一层，再次搜索。
因此回溯算法与 DFS 的区别就是有无状态重置

回溯算法关键在于:不合适就退回上一步，然后通过约束条件, 减少时间复杂度。

回溯算法 采用试错 的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，
它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：
（1）找到一个可能存在的正确的答案；②在尝试了所有可能的分步方法后宣告该问题没有答案。


六、二分查找代码模板
public int binarySearch(int[] array, int target) {
    int left = 0, right = array.length - 1, mid;
    while (left <= right) {
        mid = (right - left) / 2 + left;

        if (target == array[mid]) {
            return mid;
        } else if (target < array[mid]) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }

    return -1;
}

七、BFS模板-迭代
    /**
     * 107. 二叉树的层序遍历 -- 方法一：BFS广度遍历-迭代
     *
     * 时间复杂度：O(n)，每个点进队出队各一次，故渐进时间复杂度为 O(n)；
     * 空间复杂度：O(n)，队列中元素的个数不超过 nn 个，故渐进空间复杂度为 O(n)。
     *
     * @param root
     * @return
     */
    fun levelOrder(root: TreeNode?): List<List<Int>>? {
        // 1.1 创建一个存放最终结果的集合 和 存放节点的队列
        val res: MutableList<List<Int>> = mutableListOf()
        val queue: Queue<TreeNode> = LinkedList()

        // 1.2 根节点不==null，将根节点放入其中
        if (root == null) return res else queue.offer(root)

        // 2.1 遍历每一层前，下层的队列不为空，继续遍历
        while (queue.isNotEmpty()) {
            val list: MutableList<Int> = mutableListOf()
            // 2.2 将这一层的元素全部取出，因为长度已确定，不会遍历新加入的左右节点
            for (i in 0 until queue.size) {
                val node = queue.poll()
                // 2.3 添加遍历后的元素到集合中
                list.add(node.`val`)

                // 3 如果节点的左右孩子不为空，放入队列
                if (node.left != null) queue.offer(node.left)
                if (node.right != null) queue.offer(node.right)
            }

            // 4 赋值到集合中
            res.add(list)
        }

        return res
    }


八、DFS模板

1、不要小看这几行破代码，几乎所有二叉树的题目都是一套这个框架就出来了。
void traverse(TreeNode root) {
    // 前序遍历
    traverse(root.left)
    // 中序遍历
    traverse(root.right)
    // 后序遍历
}

2、递归
/**
 * 107. 二叉树的层序遍历 -- DFS深度遍历-递归
 * 思想：每次递归的时候都需要带一个 index(表示当前的层数)，也就对应那个田字格子中的第几行，如果当前行对应的 list 不存在，就加入一个空 list 进去。
 * 时间复杂度：O(n)，每个点进队出队各一次，故渐进时间复杂度为 O(n)；
 * 空间复杂度：O(h)，h 是树的高度。
 * @param root
 * @return
*/
fun levelOrder1(root: TreeNode?): List<List<Int>>? {
    // 存放最终结果的集合
    val res: MutableList<MutableList<Int>> = mutableListOf()
    if (root == null) return res

    dfsLevel(1, root, res)
    return res
}

fun dfsLevel(index: Int, root: TreeNode?, res: MutableList<MutableList<Int>>) {
    if (root == null) return

    // 假设res是[[1],[2,3]]，index是3，就再插入一个空list放到res中
    if (res.size < index) res.add(mutableListOf())

    // 将当前节点的值加入到res中，index-1代表当前层，假设index-1是3-1=2，节点值是6。res是[[1],[2,5],[3,4]]，加入后res就变为[[1],[2,5],[3,4,6]]
    res[index - 1].add(root.`val`)

    // 递归的处理左子树，右子树，同时将层数index+1
    if (root.left != null) dfsLevel(index + 1, root.left, res)

    if (root.right != null) dfsLevel(index + 1, root.right, res)
}

2、迭代
fun preorder1(root: Node?): List<Int> {
    val res: MutableList<Int> = mutableListOf()
    val stack: Deque<Node?> = LinkedList()

    if (root == null) return res else stack.push(root)

    while (!stack.isEmpty()) {
        // 将根节点弹出
        val p = stack.pop()
        // 加入到结果集合中
        res.add(p!!.`val`)

        // 将该节点的子节点从右往左压入栈
        for (i in p.children.size - 1 downTo 0) {
            stack.push(p.children[i])
        }
    }
    return res
}

fun postorder1(root: Node?): List<Int> {
    val res: MutableList<Int> = mutableListOf()
    val stack: Deque<Node?> = LinkedList()

    if (root == null) return res else stack.push(root)

    while (!stack.isEmpty()) {
        // 将根节点弹出
        val node = stack.pop()
        // 加入到结果集合中
        res.add(node!!.`val`)

        // 将该节点的子节点从左往右压入栈
        for (i in 0 until node.children.size) {
            stack.push(node.children[i])
        }
    }
    // 最后将list反转
    return res.reversed()
}


九、并查集
class UnionFind(n: Int) {

    private var count = 0
    private var parent: IntArray

    /**
     * 用 parent 数组记录每个节点的父节点，相当于指向父节点的指针，所以 parent 数组内实际存储着一个森林（若干棵多叉树）
     * 构造函数，n 为图的节点总数
     * @param x
     * @return
     */
    init {
        // 一开始互不连通
        count = n
        parent = IntArray(n)
        // 父节点指针初始指向自己
        for (i in 0 until n) parent[i] = i
    }

    /**
     * 返回某个节点 x 的根节点
     * @param x
     * @return
     */
    fun find(x: Int): Int {
        // 根节点的 parent[x] == x
        var x = x
        while (parent[x] != x) {
            // 进行路径压缩
            parent[x] = parent[parent[x]]
            x = parent[x]
        }
        return x
    }

    /**
     * 合并
     * @param p
     * @param q
     */
    fun union(p: Int, q: Int) {
        val rootP = find(p)
        val rootQ = find(q)
        if (rootP == rootQ) return

        // 将两棵树合并为一棵
        parent[rootP] = rootQ
        count--
    }
}















